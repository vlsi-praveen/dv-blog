<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Memory & FIFO Projects for VLSI Engineers</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.8;
            color: #333;
            background: #f8f9fa;
        }
        .header-banner {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            color: white;
            padding: 60px 20px;
            text-align: center;
        }
        .header-banner h1 {
            font-size: 2.5em;
            margin-bottom: 15px;
            font-weight: 700;
        }
        .header-banner .subtitle {
            font-size: 1.2em;
            opacity: 0.9;
        }
        .header-banner .meta {
            margin-top: 20px;
            font-size: 0.95em;
            opacity: 0.8;
        }
        .view-counter {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: #1a1a2e;
            padding: 12px 20px;
            border-radius: 25px;
            font-size: 1em;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            z-index: 1000;
        }
        .view-counter span {
            font-weight: bold;
            color: #4fc3f7;
        }
        .container {
            max-width: 800px;
            margin: 0 auto;
            padding: 40px 20px;
            background: white;
            box-shadow: 0 0 20px rgba(0,0,0,0.1);
        }
        h2 {
            color: #1a1a2e;
            font-size: 1.8em;
            margin: 40px 0 20px 0;
            padding-bottom: 10px;
            border-bottom: 3px solid #0f3460;
        }
        h3 {
            color: #16213e;
            font-size: 1.4em;
            margin: 30px 0 15px 0;
        }
        h4 {
            color: #333;
            font-size: 1.1em;
            margin: 20px 0 10px 0;
        }
        p {
            margin-bottom: 15px;
            text-align: justify;
        }
        pre {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.85em;
            line-height: 1.5;
            margin: 20px 0;
        }
        code {
            font-family: 'Consolas', 'Monaco', monospace;
            background: #f0f0f0;
            padding: 2px 6px;
            border-radius: 3px;
        }
        pre code {
            background: none;
            padding: 0;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
        }
        th {
            background: #0f3460;
            color: white;
        }
        tr:nth-child(even) {
            background: #f8f9fa;
        }
        .toc {
            background: #e8f4f8;
            padding: 25px;
            border-radius: 8px;
            margin: 30px 0;
        }
        .toc h3 {
            margin-top: 0;
            color: #0f3460;
        }
        .toc ol {
            margin-left: 25px;
        }
        .toc li {
            margin: 8px 0;
        }
        .toc a {
            color: #0f3460;
            text-decoration: none;
        }
        .toc a:hover {
            text-decoration: underline;
        }
        .project-card {
            background: linear-gradient(to right, #f8f9fa, #e8f4f8);
            border-left: 4px solid #0f3460;
            padding: 20px;
            margin: 25px 0;
            border-radius: 0 8px 8px 0;
        }
        .project-card h3 {
            margin-top: 0;
            color: #0f3460;
        }
        .interview-box {
            background: #fff3cd;
            border: 1px solid #ffc107;
            padding: 20px;
            border-radius: 8px;
            margin: 30px 0;
        }
        .interview-box h3 {
            color: #856404;
            margin-top: 0;
        }
        .cdc-box {
            background: #d4edda;
            border: 1px solid #28a745;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
        }
        .cdc-box h4 {
            color: #155724;
            margin-top: 0;
        }
        .tags {
            margin-top: 30px;
        }
        .tag {
            display: inline-block;
            background: #e8f4f8;
            color: #0f3460;
            padding: 5px 12px;
            border-radius: 20px;
            margin: 5px;
            font-size: 0.85em;
        }
        .diagram {
            background: #f8f9fa;
            border: 1px solid #ddd;
            padding: 15px;
            border-radius: 8px;
            font-family: 'Consolas', monospace;
            font-size: 0.85em;
            overflow-x: auto;
            white-space: pre;
            margin: 20px 0;
        }
        footer {
            text-align: center;
            padding: 20px;
            color: #666;
            font-size: 0.9em;
        }
        ul, ol {
            margin-left: 25px;
            margin-bottom: 15px;
        }
        li {
            margin: 5px 0;
        }
        hr {
            border: none;
            border-top: 1px solid #ddd;
            margin: 40px 0;
        }
        .nav-bar {
            background: #0f3460;
            padding: 10px 20px;
            text-align: center;
        }
        .nav-bar a {
            color: white;
            text-decoration: none;
            margin: 0 15px;
            font-size: 0.95em;
        }
        .nav-bar a:hover {
            text-decoration: underline;
        }
        .nav-bar a.active {
            font-weight: bold;
            border-bottom: 2px solid #4fc3f7;
        }
        .blog-nav {
            display: flex;
            justify-content: space-between;
            margin: 30px 0;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
        }
        .blog-nav a {
            color: #0f3460;
            text-decoration: none;
            font-weight: 500;
        }
        .blog-nav a:hover {
            text-decoration: underline;
        }
        .summary-table {
            margin: 30px 0;
        }
    </style>
</head>
<body>

<div class="nav-bar">
    <a href="index.html">01: Core RTL</a>
    <a href="memory-fifo.html" class="active">02: Memory & FIFO</a>
</div>


<div class="header-banner">
    <h1>Memory & FIFO Projects for VLSI Engineers</h1>
    <p class="subtitle">Master CDC-Safe Designs with Complete Verilog Implementations</p>
    <p class="meta"><strong>Praveen Kumar Vagala</strong> | 12 min read</p>
</div>

<div class="view-counter">
    <span id="visit-count">1000</span>
</div>

<div class="container">

    <h2>Introduction</h2>
    <p>
        Memory and FIFO designs are critical components in any digital system. FIFOs handle data buffering between different clock domains or processing units, while RAM/ROM provide storage. This blog covers synchronous and asynchronous FIFOs with CDC-safe implementations.
    </p>

    <div class="toc">
        <h3>Table of Contents</h3>
        <ol>
            <li><a href="#sync-fifo">Synchronous FIFO Design</a></li>
            <li><a href="#async-fifo">Asynchronous FIFO (CDC-Safe)</a></li>
            <li><a href="#dual-port">Dual-Port RAM Controller</a></li>
            <li><a href="#rom">ROM with Multiple Address Modes</a></li>
        </ol>
    </div>

    <hr>

    <!-- PROJECT 1: Synchronous FIFO -->
    <div class="project-card" id="sync-fifo">
        <h3>1. Synchronous FIFO Design</h3>
        <p><strong>Difficulty:</strong> Beginner | <strong>Key Learning:</strong> Single clock domain, pointer management</p>
    </div>

    <h4>Concept</h4>
    <p>
        A synchronous FIFO operates on a single clock domain. Both read and write operations are synchronized to the same clock.
    </p>

    <h4>Block Diagram</h4>
    <div class="diagram">                    +---------------------------+
     wr_en -------->|                           |
     wr_data[N] --->|     Synchronous FIFO      |-------> rd_data[N]
                    |                           |
     rd_en -------->|    +---------------+      |-------> empty
                    |    |   Memory      |      |-------> full
     clk ---------->|    |   Array       |      |-------> almost_empty
     rst_n -------->|    +---------------+      |-------> almost_full
                    |                           |
                    +---------------------------+</div>

    <h4>Verilog Code</h4>
    <pre>module sync_fifo #(
    parameter DATA_WIDTH = 8,
    parameter DEPTH      = 16,
    parameter ADDR_WIDTH = $clog2(DEPTH)
)(
    input  wire                    clk,
    input  wire                    rst_n,
    
    // Write interface
    input  wire                    wr_en,
    input  wire [DATA_WIDTH-1:0]   wr_data,
    
    // Read interface
    input  wire                    rd_en,
    output wire [DATA_WIDTH-1:0]   rd_data,
    
    // Status flags
    output wire                    empty,
    output wire                    full,
    output wire                    almost_empty,
    output wire                    almost_full,
    output wire [ADDR_WIDTH:0]     count
);

    // Memory array
    reg [DATA_WIDTH-1:0] mem [0:DEPTH-1];
    
    // Pointers
    reg [ADDR_WIDTH:0] wr_ptr;
    reg [ADDR_WIDTH:0] rd_ptr;
    
    // FIFO count
    wire [ADDR_WIDTH:0] fifo_count;
    assign fifo_count = wr_ptr - rd_ptr;
    assign count = fifo_count;
    
    // Status flags
    assign empty        = (fifo_count == 0);
    assign full         = (fifo_count == DEPTH);
    assign almost_empty = (fifo_count <= 1);
    assign almost_full  = (fifo_count >= DEPTH - 1);
    
    // Write operation
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            wr_ptr <= 0;
        end else if (wr_en && !full) begin
            mem[wr_ptr[ADDR_WIDTH-1:0]] <= wr_data;
            wr_ptr <= wr_ptr + 1;
        end
    end
    
    // Read operation
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            rd_ptr <= 0;
        end else if (rd_en && !empty) begin
            rd_ptr <= rd_ptr + 1;
        end
    end
    
    // Read data (combinational)
    assign rd_data = mem[rd_ptr[ADDR_WIDTH-1:0]];

endmodule</pre>

    <h4>Testbench</h4>
    <pre>module tb_sync_fifo;
    parameter DATA_WIDTH = 8;
    parameter DEPTH = 8;
    
    reg                    clk, rst_n;
    reg                    wr_en, rd_en;
    reg  [DATA_WIDTH-1:0]  wr_data;
    wire [DATA_WIDTH-1:0]  rd_data;
    wire                   empty, full;
    
    sync_fifo #(.DATA_WIDTH(DATA_WIDTH), .DEPTH(DEPTH)) uut (.*);
    
    always #5 clk = ~clk;
    
    initial begin
        clk = 0; rst_n = 0; wr_en = 0; rd_en = 0;
        #20 rst_n = 1;
        
        // Write data
        repeat(5) begin
            @(posedge clk);
            wr_en = 1;
            wr_data = $random;
        end
        @(posedge clk);
        wr_en = 0;
        
        // Read data
        repeat(5) begin
            @(posedge clk);
            rd_en = 1;
            $display("Read: %h", rd_data);
        end
        @(posedge clk);
        rd_en = 0;
        
        #50 $finish;
    end
endmodule</pre>

    <h4>Common Mistakes to Avoid</h4>
    <ol>
        <li><strong>Not handling simultaneous read/write</strong> - Define behavior clearly</li>
        <li><strong>Overflow/underflow conditions</strong> - Check full/empty before operations</li>
        <li><strong>Incorrect pointer width</strong> - Use $clog2 for address width</li>
    </ol>

    <hr>

    <!-- PROJECT 2: Asynchronous FIFO -->
    <div class="project-card" id="async-fifo">
        <h3>2. Asynchronous FIFO (CDC-Safe)</h3>
        <p><strong>Difficulty:</strong> Advanced | <strong>Key Learning:</strong> Gray code, 2-FF synchronizers, CDC</p>
    </div>

    <h4>Concept</h4>
    <p>
        An asynchronous FIFO bridges two different clock domains. It uses Gray code pointers and dual-flop synchronizers for safe CDC (Clock Domain Crossing).
    </p>

    <h4>Why Gray Code?</h4>
    <p>
        Gray code changes only one bit at a time, preventing metastability issues when synchronizing multi-bit pointers across clock domains.
    </p>
    <div class="diagram">Binary:  000 -> 001 -> 010 -> 011 -> 100 -> 101 -> 110 -> 111
Gray:    000 -> 001 -> 011 -> 010 -> 110 -> 111 -> 101 -> 100
                 ^      ^      ^      ^      ^      ^      ^
            (only 1 bit changes at each transition)</div>

    <h4>Block Diagram</h4>
    <div class="diagram">    Write Clock Domain          |         Read Clock Domain
                                |
    wr_clk   wr_en   wr_data    |    rd_clk   rd_en
       |       |        |       |       |       |
       v       v        v       |       v       v
    +----------------------+    |    +----------------------+
    |   Write Pointer      |    |    |   Read Pointer       |
    |   (Binary -> Gray)   |    |    |   (Binary -> Gray)   |
    +----------+-----------+    |    +----------+-----------+
               |                |                |
               | Gray Ptr      |                | Gray Ptr
               v                |                v
    +----------------------+    |    +----------------------+
    |  2-FF Synchronizer   |<---|    |  2-FF Synchronizer   |
    |  (rd_ptr to wr_clk)  |    |--->|  (wr_ptr to rd_clk)  |
    +----------------------+    |    +----------------------+
               |                |                |
               v                |                v
         full flag              |          empty flag
                                |
              +--------Memory--------+
              |       (Dual-Port)    |
              +----------------------+</div>

    <h4>Verilog Code</h4>
    <pre>// Gray code converter
module bin2gray #(parameter WIDTH = 4) (
    input  wire [WIDTH-1:0] bin,
    output wire [WIDTH-1:0] gray
);
    assign gray = bin ^ (bin >> 1);
endmodule

module gray2bin #(parameter WIDTH = 4) (
    input  wire [WIDTH-1:0] gray,
    output wire [WIDTH-1:0] bin
);
    genvar i;
    generate
        for (i = 0; i < WIDTH; i = i + 1) begin : gen_bin
            assign bin[i] = ^gray[WIDTH-1:i];
        end
    endgenerate
endmodule

// 2-FF Synchronizer
module sync_2ff #(parameter WIDTH = 4) (
    input  wire             clk,
    input  wire             rst_n,
    input  wire [WIDTH-1:0] din,
    output reg  [WIDTH-1:0] dout
);
    reg [WIDTH-1:0] meta;
    
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            meta <= 0;
            dout <= 0;
        end else begin
            meta <= din;
            dout <= meta;
        end
    end
endmodule

// Asynchronous FIFO
module async_fifo #(
    parameter DATA_WIDTH = 8,
    parameter DEPTH      = 16,
    parameter ADDR_WIDTH = $clog2(DEPTH)
)(
    // Write clock domain
    input  wire                    wr_clk,
    input  wire                    wr_rst_n,
    input  wire                    wr_en,
    input  wire [DATA_WIDTH-1:0]   wr_data,
    output wire                    full,
    
    // Read clock domain
    input  wire                    rd_clk,
    input  wire                    rd_rst_n,
    input  wire                    rd_en,
    output wire [DATA_WIDTH-1:0]   rd_data,
    output wire                    empty
);

    localparam PTR_WIDTH = ADDR_WIDTH + 1;
    
    // Dual-port memory
    reg [DATA_WIDTH-1:0] mem [0:DEPTH-1];
    
    // Write domain signals
    reg  [PTR_WIDTH-1:0] wr_ptr_bin;
    wire [PTR_WIDTH-1:0] wr_ptr_gray;
    wire [PTR_WIDTH-1:0] rd_ptr_gray_sync;
    
    // Read domain signals
    reg  [PTR_WIDTH-1:0] rd_ptr_bin;
    wire [PTR_WIDTH-1:0] rd_ptr_gray;
    wire [PTR_WIDTH-1:0] wr_ptr_gray_sync;
    
    // Binary to Gray conversion
    bin2gray #(PTR_WIDTH) wr_b2g (.bin(wr_ptr_bin), .gray(wr_ptr_gray));
    bin2gray #(PTR_WIDTH) rd_b2g (.bin(rd_ptr_bin), .gray(rd_ptr_gray));
    
    // Synchronizers
    sync_2ff #(PTR_WIDTH) sync_rd_ptr (
        .clk(wr_clk), .rst_n(wr_rst_n),
        .din(rd_ptr_gray), .dout(rd_ptr_gray_sync)
    );
    
    sync_2ff #(PTR_WIDTH) sync_wr_ptr (
        .clk(rd_clk), .rst_n(rd_rst_n),
        .din(wr_ptr_gray), .dout(wr_ptr_gray_sync)
    );
    
    // Full flag generation (write domain)
    assign full = (wr_ptr_gray == {~rd_ptr_gray_sync[PTR_WIDTH-1:PTR_WIDTH-2], 
                                    rd_ptr_gray_sync[PTR_WIDTH-3:0]});
    
    // Empty flag generation (read domain)
    assign empty = (rd_ptr_gray == wr_ptr_gray_sync);
    
    // Write logic
    always @(posedge wr_clk or negedge wr_rst_n) begin
        if (!wr_rst_n) begin
            wr_ptr_bin <= 0;
        end else if (wr_en && !full) begin
            mem[wr_ptr_bin[ADDR_WIDTH-1:0]] <= wr_data;
            wr_ptr_bin <= wr_ptr_bin + 1;
        end
    end
    
    // Read logic
    always @(posedge rd_clk or negedge rd_rst_n) begin
        if (!rd_rst_n) begin
            rd_ptr_bin <= 0;
        end else if (rd_en && !empty) begin
            rd_ptr_bin <= rd_ptr_bin + 1;
        end
    end
    
    assign rd_data = mem[rd_ptr_bin[ADDR_WIDTH-1:0]];

endmodule</pre>

    <div class="cdc-box">
        <h4>âœ… CDC Verification Checklist</h4>
        <ol>
            <li>Gray code pointers (single bit change)</li>
            <li>2-FF synchronizers for pointer crossing</li>
            <li>Full generated in write domain</li>
            <li>Empty generated in read domain</li>
            <li>FIFO depth must be power of 2</li>
        </ol>
    </div>

    <div class="interview-box">
        <h3>Interview Questions</h3>
        <ol>
            <li><strong>Why Gray code for async FIFO?</strong> - Only one bit changes at a time, preventing intermediate wrong values during synchronization</li>
            <li><strong>Why 2-FF synchronizer?</strong> - Reduces probability of metastability to acceptable levels</li>
            <li><strong>Can full/empty flags be wrong?</strong> - They can be pessimistic (show full when not quite full) but never optimistic - this is safe behavior</li>
        </ol>
    </div>

    <hr>

    <!-- PROJECT 3: Dual-Port RAM -->
    <div class="project-card" id="dual-port">
        <h3>3. Dual-Port RAM Controller</h3>
        <p><strong>Difficulty:</strong> Intermediate | <strong>Key Learning:</strong> Two independent ports, simultaneous access</p>
    </div>

    <h4>Concept</h4>
    <p>
        Dual-port RAM allows simultaneous read and write operations from two independent ports.
    </p>

    <h4>Verilog Code</h4>
    <pre>module dual_port_ram #(
    parameter DATA_WIDTH = 32,
    parameter ADDR_WIDTH = 10,
    parameter DEPTH      = 1024
)(
    // Port A
    input  wire                    clk_a,
    input  wire                    en_a,
    input  wire                    wr_en_a,
    input  wire [ADDR_WIDTH-1:0]   addr_a,
    input  wire [DATA_WIDTH-1:0]   wr_data_a,
    output reg  [DATA_WIDTH-1:0]   rd_data_a,
    
    // Port B
    input  wire                    clk_b,
    input  wire                    en_b,
    input  wire                    wr_en_b,
    input  wire [ADDR_WIDTH-1:0]   addr_b,
    input  wire [DATA_WIDTH-1:0]   wr_data_b,
    output reg  [DATA_WIDTH-1:0]   rd_data_b
);

    // Memory array
    reg [DATA_WIDTH-1:0] mem [0:DEPTH-1];
    
    // Port A operations
    always @(posedge clk_a) begin
        if (en_a) begin
            if (wr_en_a)
                mem[addr_a] <= wr_data_a;
            rd_data_a <= mem[addr_a];
        end
    end
    
    // Port B operations
    always @(posedge clk_b) begin
        if (en_b) begin
            if (wr_en_b)
                mem[addr_b] <= wr_data_b;
            rd_data_b <= mem[addr_b];
        end
    end

endmodule</pre>

    <h4>True Dual-Port vs Simple Dual-Port</h4>
    <table>
        <tr>
            <th>Feature</th>
            <th>True Dual-Port</th>
            <th>Simple Dual-Port</th>
        </tr>
        <tr>
            <td>Port A</td>
            <td>Read/Write</td>
            <td>Write only</td>
        </tr>
        <tr>
            <td>Port B</td>
            <td>Read/Write</td>
            <td>Read only</td>
        </tr>
        <tr>
            <td>Complexity</td>
            <td>Higher</td>
            <td>Lower</td>
        </tr>
        <tr>
            <td>Use case</td>
            <td>Shared memory</td>
            <td>FIFO backing store</td>
        </tr>
    </table>

    <hr>

    <!-- PROJECT 4: ROM -->
    <div class="project-card" id="rom">
        <h3>4. ROM with Multiple Address Modes</h3>
        <p><strong>Difficulty:</strong> Intermediate | <strong>Key Learning:</strong> Flexible addressing patterns</p>
    </div>

    <h4>Concept</h4>
    <p>
        ROM stores pre-initialized data. Multiple address modes allow flexible access patterns (direct, indexed, indirect).
    </p>

    <h4>Verilog Code</h4>
    <pre>module rom_multi_mode #(
    parameter DATA_WIDTH = 16,
    parameter ADDR_WIDTH = 8,
    parameter DEPTH      = 256
)(
    input  wire                    clk,
    input  wire                    en,
    input  wire [1:0]              addr_mode,
    input  wire [ADDR_WIDTH-1:0]   base_addr,
    input  wire [ADDR_WIDTH-1:0]   offset,
    input  wire [ADDR_WIDTH-1:0]   indirect_addr,
    output reg  [DATA_WIDTH-1:0]   data_out,
    output reg                     valid
);

    // Address modes
    localparam DIRECT   = 2'b00;  // Use base_addr directly
    localparam INDEXED  = 2'b01;  // base_addr + offset
    localparam INDIRECT = 2'b10;  // Address stored at indirect_addr
    localparam AUTO_INC = 2'b11;  // Auto-increment mode
    
    // ROM memory (initialized)
    reg [DATA_WIDTH-1:0] rom [0:DEPTH-1];
    
    // Auto-increment counter
    reg [ADDR_WIDTH-1:0] auto_ptr;
    
    // Effective address
    reg [ADDR_WIDTH-1:0] eff_addr;
    wire [ADDR_WIDTH-1:0] indirect_data;
    
    // Initialize ROM with sample data
    initial begin
        integer i;
        for (i = 0; i < DEPTH; i = i + 1) begin
            rom[i] = i * 2;  // Sample initialization
        end
    end
    
    // For indirect mode, first read gives address
    assign indirect_data = rom[indirect_addr][ADDR_WIDTH-1:0];
    
    // Address calculation
    always @(*) begin
        case (addr_mode)
            DIRECT:   eff_addr = base_addr;
            INDEXED:  eff_addr = base_addr + offset;
            INDIRECT: eff_addr = indirect_data;
            AUTO_INC: eff_addr = auto_ptr;
            default:  eff_addr = base_addr;
        endcase
    end
    
    // Read operation
    always @(posedge clk) begin
        if (en) begin
            data_out <= rom[eff_addr];
            valid <= 1'b1;
            
            // Auto-increment pointer
            if (addr_mode == AUTO_INC)
                auto_ptr <= auto_ptr + 1;
        end else begin
            valid <= 1'b0;
        end
    end
    
    // Reset auto pointer
    always @(posedge clk) begin
        if (addr_mode != AUTO_INC)
            auto_ptr <= base_addr;
    end

endmodule</pre>

    <h4>Address Mode Examples</h4>
    <div class="diagram">DIRECT Mode:
  base_addr = 0x10  -->  Read from ROM[0x10]

INDEXED Mode:
  base_addr = 0x10, offset = 0x05  -->  Read from ROM[0x15]

INDIRECT Mode:
  indirect_addr = 0x20
  ROM[0x20] = 0x50  -->  Read from ROM[0x50]

AUTO_INC Mode:
  First read:  ROM[base_addr]
  Next read:   ROM[base_addr + 1]
  Next read:   ROM[base_addr + 2]
  ...</div>

    <hr>

    <!-- Summary -->
    <h2>Summary</h2>
    
    <table class="summary-table">
        <tr>
            <th>Design</th>
            <th>Key Concept</th>
            <th>CDC Safe?</th>
        </tr>
        <tr>
            <td>Sync FIFO</td>
            <td>Single clock, simple pointers</td>
            <td>N/A</td>
        </tr>
        <tr>
            <td>Async FIFO</td>
            <td>Gray code, 2-FF sync</td>
            <td>Yes</td>
        </tr>
        <tr>
            <td>Dual-Port RAM</td>
            <td>Two independent ports</td>
            <td>Depends</td>
        </tr>
        <tr>
            <td>Multi-Mode ROM</td>
            <td>Flexible addressing</td>
            <td>N/A</td>
        </tr>
    </table>

    <hr>

    <div class="interview-box">
        <h3>More Interview Questions</h3>
        <ol>
            <li><strong>Why is FIFO depth always power of 2?</strong> - For proper Gray code wrapping and pointer comparison</li>
            <li><strong>What happens if 2-FF sync captures metastable value?</strong> - Second FF has full clock period to resolve; probability of failure is extremely low (MTBF in years)</li>
            <li><strong>How to handle simultaneous read/write to same address in dual-port RAM?</strong> - Define priority (write-first, read-first, or no-change mode)</li>
            <li><strong>What is CDC?</strong> - Clock Domain Crossing - transferring signals between different clock domains</li>
        </ol>
    </div>

    <h2>Next Steps</h2>
    <p>After mastering memory and FIFO designs, proceed to:</p>
    <ul>
        <li>Communication protocols (UART, SPI, I2C)</li>
        <li>Processor architecture (RISC-V)</li>
        <li>AMBA bus protocols (AXI, AHB, APB)</li>
    </ul>


    <div class="blog-nav">
        <a href="index.html"> Previous: Core RTL Design</a>
        <span></span>
    </div>
    <div class="tags">
        <span class="tag">#Verilog</span>
        <span class="tag">#FIFO</span>
        <span class="tag">#CDC</span>
        <span class="tag">#Memory</span>
        <span class="tag">#Gray Code</span>
        <span class="tag">#VLSI</span>
        <span class="tag">#FPGA</span>
        <span class="tag">#ASIC</span>
    </div>

</div>

<footer>
    <p>Code examples are for educational purposes. Verify functionality before production use.</p>
</footer>

<script type="module">
    // Firebase Global Counter
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
    import { getDatabase, ref, runTransaction } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js";

    const firebaseConfig = {
        databaseURL: "https://vlsi-blog-counter-default-rtdb.firebaseio.com/"
    };

    const app = initializeApp(firebaseConfig);
    const database = getDatabase(app);
    const counterRef = ref(database, 'blog02Views');

    // Increment counter atomically
    runTransaction(counterRef, (currentValue) => {
        if (currentValue === null) {
            return 1000;  // Start from 1000 if no value exists
        }
        return currentValue + 1;
    }).then((result) => {
        document.getElementById('visit-count').textContent = result.snapshot.val();
    }).catch((error) => {
        console.error('Counter error:', error);
        document.getElementById('visit-count').textContent = '1000+';
    });
</script>

</body>
</html>